---
title: "Go数据结构和算法-链表"
date: 2020-03-21T19:21:26+08:00
draft: false
comment: false
url: /2020/03/21/golang-.html
tags: ["数据结构和算法"]
categories: ["Golang"]
---
- 单链表实现
- 单链表增删改查
- 双向链表实现
- 双向链表增删改查
<!--more-->

链表是一个有序(FIFO)的列表
## 单链表
单链表: 带头节点的链表  
头节点的作用: 不存放数据，用来标识链表头，为了方便的对单链表进行增删改查

### 单链表实现
next指向下一个节点
```go
type heroNode struct {
	number   int
	name     string
	nickname string
	next *heroNode
}
```
### 给单链表新增节点
直接在链表尾部插入  
思路: 判断当前节点是否为最后一个节点,如果是则插入，不是则遍历下个节点
```go
func insert(head *heroNode, newHeroNode *heroNode) {
	for {
		// 如果 true 表示找到链表末尾; 并赋值插入
		if head.next == nil {
			head.next = newHeroNode
			return
		} else {
			// 当前node不是，则进入下一个node
			head = head.next
        }
        
	}

}
```
根据编号从小到大排列插入相应位置  
前提: 节点已是从小到大排列顺序  
思路: 带插入节点`newHeroNode.number`编号小于`head.next.number`则找到位置
```go
func insertById(head *heroNode, newHeroNode *heroNode) {
	for {
		// 如果 true 表示找到链表末尾; 并赋值
		if head.next == nil {
			head.next = newHeroNode
			return
		} else if newHeroNode.number < head.next.number {
			newHeroNode.next = head.next
			head.next = newHeroNode
			return
		} else if newHeroNode.number == head.next.number {
			fmt.Println("存在相同id，不允许插入")
			return
		} else {
			// 当前node不是，则进入下一个node
			head = head.next
		}

	}

}
```
### 删除单链表中指定节点  
思路: 当前所在节点在待删除节点前一位,将当前节点的next直接指向待删除节点中的next(取代待删除节点)
```go
func deleteById(head *heroNode, number int) {
	for {
		// 没找到符合指定条件的节点
		if head.next == nil {
			fmt.Println("不存在de序号: ", number)
			return
		} else if number == head.next.number {
			// 实现
			if head.next.next != nil {
				head.next = head.next.next
			} else {
				head.next = nil
			}
			return
		} else {
			// 当前node不是，则进入下一个node
			head = head.next
		}

	}

}
```
### 更新单链表中指定节点
```go
func update(head *heroNode, newHeroNode *heroNode) {
	for {
		// 没找到
		if head.next == nil {
			fmt.Println("不存在de序号: ", newHeroNode.number)
			return
		} else if newHeroNode.number == head.next.number {
			// 实现更新
			newHeroNode.next = head.next.next
			head.next = newHeroNode
			return
		} else {
			head = head.next
		}

	}

}
```

### 查询单链表中所有节点信息
```go
func listHeroNode(head *heroNode) {
	for {
		// 1. 判断当前 node 是否为末尾 node ( 当前 node 的 next 的值是否是空指针 nil)
		if head.next == nil {
			return
		}

		// 2. 不是则输出 info
		fmt.Printf("排名: %d \t 姓名: %s \t 昵称: %s \n", head.next.number, head.next.name, head.next.nickname)

		// 3. "移至"下一个节点
		head = head.next
	}

}

```

### 测试
```go
func main() {
	// 1. 先创建一个头节点，
	head := &heroNode{}

	// 2. 创建一个新的heroNode
	hero1 := &heroNode{
		number:   1,
		name:     "宋江",
		nickname: "及时雨",
	}

	hero2 := &heroNode{
		number:   2,
		name:     "林冲",
		nickname: "豹子头",
	}

	hero3 := &heroNode{
		number:   3,
		name:     "卢俊义",
		nickname: "玉麒麟",
	}

	hero4 := &heroNode{
		number:   4,
		name:     "吴用",
		nickname: "智多星",
	}

	// 3. 增
	insertById(head, hero3)
	insertById(head, hero1)
	insertById(head, hero2)
	insertById(head, hero4)
	// insertById(head, hero4)

	// 4. 查
	listHeroNode(head)

	// 5. 删
	deleteById(head, 4)

	// 6. 改
	heroUpdate := &heroNode{
		number:   2,
		name:     "林不冲",
		nickname: "狮子头",
	}
	update(head, heroUpdate)

	// 4. 查
	fmt.Println()
	listHeroNode(head)
}
```
运行结果如下：
![2020-3-22-0-47-32.png](https://raw.githubusercontent.com/Flygar/blogPics/dev/img/2020-3-22-0-47-32.png)

## 双向链表
