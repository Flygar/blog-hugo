---
title: Golang Bit Operation
date: 2018-08-12 18:28:46
---

>Bool类型的零值“false”
>"&&":有假则假;"||":有真则真;
>当运算符左边表达式的值已经能够决定整个表达式的值的时候(&& 左边的值为 false，|| 左边的值为 true)，运算符右边的表达式将不会被执行。利用这个性 质，如果有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。

<!-- more -->

### bit位运算
```go
ax := 1 << 1 //  00000010
bx := 1 << 5 //  00100000
// 按位或 | : 有1则1
cx := ax | bx //  00100010
fmt.Printf("ax(%d)的二进制: %08b\nbx(%d)的二进制: %08b\ncx(%d)的二进制: %08b\n", ax, ax, bx, bx, cx, cx)

ay := 4 >> 1 //  00000010
by := 7 >> 1 //  00000011
// 按位与 & : 有0则0
cy := ay & by //  00000010
fmt.Printf("ay(%d)的二进制: %08b\nby(%d)的二进制: %08b\ncy(%d)的二进制: %08b\n", ay, ay, by, by, cy, cy)

//按位异或 ^ : 相同0，不同1;
fmt.Printf("%d: %08b\n", cx^cy, cx^cy)//00100010^00000010=00100000

//按位置零 &^ : z=x&^y:如果对应y中bit位为1的话，z的bit位为0，否则对应的bit位等于x相应的bit位的值.
fmt.Printf("%d: %08b\n", cx&^cy, cx&^cy) //00100010&^00000010=00100000
fmt.Printf("%d: %08b\n", ax&^bx, ax&^bx) //00000010&^00100000=00000010

for i := uint(0); i < 8; i++ {
	if cx&(1<<i) != 0 { // membership test
		fmt.Println(i) // "1", "5"
	}
}
fmt.Printf("%08b\n", cx<<1) // "01000100", the set {2, 6}
fmt.Printf("%08b\n", cx>>1) // "00010001", the set {0, 4}
```

```go
// 按位与 & 
1 & 1 -> 1 
1 & 0 -> 0 
0 & 1 -> 0 
0 & 0 -> 0

// 按位或 | 
1 | 1 -> 1 
1 | 0 -> 1 
0 | 1 -> 1 
0 | 0 -> 0

// 按位异或 ^ : 相同0，不同1; 
1 ^ 1 -> 0 
1 ^ 0 -> 1 
0 ^ 1 -> 1 
0 ^ 0 -> 0

// 按位置零 &^ : z=x&^y:如果对应y中bit位为1的话，z的bit位为0，否则对应的bit位等于x相应的bit位的值。
1 &^ 1 -> 0
1 &^ 0 -> 1 
0 &^ 1 -> 0 
0 &^ 0 -> 0

// 左移 
//x*(2的y次方)
x<<y 
// 5*(2^3)=40  
5<<3  

// 右移
// x*(2的-y次方)
x>>y   
// 800*(2^(-3))=100
800>>3 
// 100的二进制：01100100 往右移动3位：00001100 (十进制：12)
100>>3 
```

### 优化
>因为位运算比/运算快;

```go
// 相当于：x=x/2;
x=x>>1;  
const (
	_   = 1 << (10 * iota)
	KiB //1024
	MiB //1048576
	GiB //1073741824
	Tib //1099511627776
	PiB //1125899906842624
)
```
